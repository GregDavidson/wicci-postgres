#!/usr/bin/bash

# Note: =Emacs= =outshine-mode= lets you treat this file as a hierarchical
# document. TAB on comment lines beginning with asterisks will hide/show nodes
# much like with =OrgMode=.

# * Install PostgreSQL for the Wicci

# Run script with no arguments for help!

# ** A Few Initial Settings

# set -vx                         # DEBUG !!

# exit on command failures
# commented out as some of our functions "fail"
# research this as it would be nice to reinstate this protection!
# possibly just need some strategic
# - add last statement: return 0
# - add trailing: || true
# set -e
# exit when referencing undefined variables
set -u
set -o pipefail                 # capture last non-zero status in pipeline

readonly Pgm_Name="${0##*/}"    # Name of this script
readonly Pgm_Dir="$(realpath "$(dirname "$0")")"

# Early_Globals will be logged once logging is available
declare -a Early_Globals=(Pgm_Name Pgm_Dir)

# ** Reporting

# Initial setup reports won't be logged.
# When we're ready to log, we'll set this:
declare -g Log_File

# Once Log_File is set, we'll only report to there,
# unless Verbose=true.

# Context is everything! Reports, including Warnings and Error Messages need to
# report context. A ContextSequence is a space-separated string consisting of a
# ContextRecords. A ContextRecord is a colon (:) separated record of an
# ExitCode, LineNumber and optional entities such as FunctionNames and
# ParameterSettings - which must not contain either spaces or colons. These
# ContextSequences generally grow as they're passed as FunctionArguments.
# ExitCodes and LineNumbers are generally computed by a tool.

# cs makes context sequences
# cs existing-context-sequence context-record-arguments
cs() {
    cs0="$1"; shift
    printf -- '%s%s%s' "$(cr "$@")" "${cs0:+ }" "$cs0"
}

# cr makes ContextRecords which are also ContextSequence singletons
# cr exit_code line_number [entity...]
cr() {
    local IFS=':'
    printf -- '%s' "$*"
}

# burst a ContextRecord into space-separated fields
cr_burst() {
    local IFS=':'
    local fields
    read -ra fields <<< "$1"
    IFS=' '
    printf -- '%s' "${fields[*]}"
}

# test whether the argument appears to be a ContextSequence
is_cs() {
    [ -z "$1" ] || [[ "X$1" =~ ^X[0-9]+: ]]
}

# returns the first ExitCode in the ContextSequence or 1 if the first
# ContextRecord doesn't seem to have one
cs_code() {
    local code got_code
    code=$(expr "X$1" : 'X\([0-9][0-9]*\):')
    got_code="$?"               # did $1 match the pattern?
    printf -- "%d" "${code:-1}" # return the code to use
    exit $got_code              # return whether it was in $1
}

# report_out [-LEVEL] [CONTEXT] [FORMAT] REPORT...
# All report messages go through here.
# Formats should work well with OrgMode.
# Currently any FORMAT option is ignored.
report_out() {
    local level='' context='' format='' cxt
    # get the level, if any
    [[ "X$1" =~ ^X-[[:alpha:]]+$ ]] && {
        level="${1#-}" ; shift  # dropping the initial -
    }
    # get the context, if any
    is_cs "$1" && { context="$1"; shift; }
    # get the format, if any
    case "$1" in
        (:*|-:*) format="$1" ; shift ;;
    esac
    # make the main report
    case "$level" in
        ?*) printf -- '- %s :: %s\n' "$level" "$*" ;;
        *) printf -- '%s\n' "$*" ;;
    esac
    # follow with all supporting context
    for cxt in $context; do
        printf -- '- context: %s\n' "$(cr_burst "$cxt")"
    done
}

# same interface as report_out
# report to stdout if Verbose or no Log_File yet
# report to Log_File if it exists
report() {
    local show=false log=false
    [ -n "${Log_File:-}" ] && log=true
    { "${Verbose:-false}" || ! "$log"; } && show=true
    "$show" && report_out "$@"
    "$log" && report_out "$@" >> "$Log_File"
}

# error CONTEXT REPORT...
error() {
    local code=$(cs_code "$1")
    >&2 report -error "$@"
    exit "$code"
}

# ** Reporting Parameter Values

report_param() {
    local -n v="$1"
    report -"\$$1" '' "$v"
}

report_param_array() {
    local -n a="$1"
    local i
    report -"$1[]" '' Elements
    for i in ${!a[@]}; do
        report -"[$1]" '' "${a[$i]}"
    done
}

report_params() {
    local p; for p; do report_param "$p"; done
}

# logging issue!!!
set_param() {
    { [ $# -ge 1 ] && [ $# -le 2 ]; } ||
        error 'set_param' "expected $# arguments"
    declare -g "$1"
    [ $# -eq 1 ] && return 0
    local -n param="$1"
    param="$2"
    ${Verbose:-false} && report_param "$1"
    [ -n "${Log_File:-}" ] || Early_Globals+=("$1")
}

set_final() {
    set_param "$@"
    declare -gr "$1"
}

# ** Specify Accounts and Locations

# Using grep
# Assumes FILE is Posix /etc/passwd or /etc/group
# user_group_exists NAME 'user|group' FILE [CONTEXT]
user_group_exists() {
    local context="${4:-}"
    grep -qs "^$1:" "$3" || error "$context" "No $2 $1 in $3"
    printf -- '%s' "$1"            # return value
}
user_exists() { user_group_exists "$1" 'user' '/etc/passwd' "${2:-}"; }
group_exists() { user_group_exists "$1" 'group' '/etc/group' "${2:-}"; }

do_suss_accounts() {
    local this=do_suss_accounts

    # The Account and Group which we use to configure and build PostgreSQL
    set_final Build_Acct "$(user_exists bin "`cr 10 186 $this`")"
    set_final Build_Group "$(group_exists bin "`cr 11 187 $this`")"
    # The Account and Group which owns the installed PostgreSQL
    set_final PG_Acct "$(user_exists postgres "`cr 12 189 $this`")"
    set_final PG_Group "$(group_exists postgres "`cr 13 190 $this`")"
}

do_suss_locations() {
    local this=do_suss_locations

    set_final Build_Grandparent_Dir /usr/local/src
    [ -d "$Build_Grandparent_Dir" ] ||
        error "`cr 14 198 $this`" expected directory "$Build_Grandparent_Dir"

    for d in /usr/local/SW.d /usr/local/SW /usr/local; do
        [ -d "$d" ] && break
    done
    [ -d "$d" ] || error "`cr 15 203 $this`" "expected PG_Parent_Dir $d"
    set_final PG_Parent_Dir "$d"
}

# ** Given Version, Specify Build and PG Dirs

# Using ls, grep
# empty_dir() { ! [ -e "$1" ] || [ -d "$1"] && ! ls -qAH -- "$1" | grep -q .; }
# just using bash builtin features
empty_dir() {
    ! [ -e "$1" ] || [ -d "$1" ] && ! [[ $(shopt -s nullglob dotglob; echo "$1"/*) ]];
}

# expect_dir PATH [CONTEXT]
expect_dir() {
    [ -d "$1" ] || error "${2:-}" "Expected directory $1"
}

# Using mkdir, chown
# ensure directory exists at PATH or mkdir and chown it
# ensure_dir PATH ACCOUNT GROUP [CONTEXT]
ensure_dir() {
    local this=ensure_dir
    local dir="$1" acct="$2" group="$3" cs_="${4:-}"
    [ -d "$dir" ] || {
        [ -e "$dir" ] &&          # whoops, something else there!
            error "$cs_" "Expected directory $dir"
        report -command "`cs "$cs_" 16 230 $this`" mkdir -p "$dir"
        mkdir "$dir"
        report -command "`cs "$cs_" 17 232 $this`" chown "$acct:$group" "$dir"
        chown "$acct:$group" "$dir"
    }
}

# when we know the version, create the build directories
# do_suss_build_dirs VERSION
do_suss_build_dirs() {
    local this=do_suss_build_dirs
    set_final Project_Name "PostgreSQL-$1"
    set_final Source_Name "${Project_Name,,}" # lower case
    set_final Build_Parent_Dir "$Build_Grandparent_Dir/$Project_Name"
    ensure_dir "$Build_Parent_Dir" "$Build_Acct" "$Build_Group" "`cr 18 244 $this`"
    local n=1 d
    while d="$Build_Parent_Dir/Attempt-$n" ; ! empty_dir "$d"; do
        let ++n
    done
    set_final Build_Dir "$d"
    ensure_dir "$Build_Dir" "$Build_Acct" "$Build_Group" "`cr 19 250 suss_build_dirs`"
}

# when we know the version, create the PG Dirs
# Initially they'll be owned by the $Build_Acct
# Later they'll be =chown=ed to the $PG_Acct
# do_suss_pg_dirs VERSION
do_suss_pg_dirs() {
    local this=do_suss_pg_dirs
    set_final PG_Dir "$PG_Parent_Dir/pgsql-$1"
    local n=1 old
    [ -d "$PG_Dir" ] && ! empty_dir "$PG_Dir" && {
            while old="$PG_Dir-$n"; [ -d "$old" ]; do
                let ++n
            done
            report "`cr 20 265 $this`" 'install conflict' mv "$PG_Dir" "$old"
            mv "$PG_Dir" "$old"
        }
    ensure_dir "$PG_Dir" "$Build_Acct" "$Build_Group" "`cr 21 268 $this`"
    set_final PG_Bin "$PG_Dir/bin"
    set_final PG_Data "$PG_Dir/data"
    set_final PG_Log "$PG_Data/logfile"
    set_final PG_Conf "$PG_Data/postgresql.conf"
    set_final PG_Conf_Orig "$PG_Conf-$Version"
}

# ** Usage Patterns

# How this script can be used

declare -r Options=('--help' '--dryrun' '--verbose')

declare -rA Patterns=( [help]=0 [tarball]=1 [git-dir]=2 [src-dir]=3 )

# In array Arg_Patterns, note Posix documentation convention
# of optional arguments in [square brackets]
declare -ra Arg_Patterns=(
''
'PATH-TO-TARBALL [PARENT-INSTALL-DIR]'
'VERSION POSTGRESQL-GIT-REPOSITORY [PARENT-INSTALL-DIR]'
'VERSION [PARENT-INSTALL-DIR]'
)
declare -ra Arg_Pattern_Explanations=(
'give help'
'install from tar archive'
'install specified version from git repository'
'install specified version from existing source'
)

# These three arrays should have the same number of elements
[ "${#Patterns[@]}" =  "${#Arg_Patterns[@]}" ] ||
    error "`cr 22 301 "$Pgm_Name"`" "#Patterns != #Arg_Patterns"
[ "${#Patterns[@]}" =  "${#Arg_Pattern_Explanations[@]}" ] ||
    error "`cr 23 303 "$Pgm_Name"`" "#Patterns != #Arg_Pattern_Explanations"

give_full_help() {
    local i
    for i in ${!Arg_Patterns[@]}; do
        printf -- '%s %s %s\n\t%s\n' \
               "$Pgm_Name" "${Options[*]}" "${Arg_Patterns[$i]}" \
               "${Arg_Pattern_Explanations[$i]}"
    done
    printf -- 'Caveats:\n'
    printf -- '\t%s\n' 'Currently needs to run as root.'
    printf -- '\t%s\n' 'Unmet dependencies should cause it to abort.'
    printf -- '\t%s\n' 'Logs and work done so far left for you to examine.'
    printf -- '\t%s\n' 'Too many assumptions for any hard guarantees!'
    printf -- '\t%s\n' 'May behave arbitrarily badly in unfamiliar environment.'
}

# ** Process Command Line Options

# Find the path to a program with fallbacks, or fail
# try_find_prog_path PROGRAM_NAME...
try_find_prog_path() {
    # set -vx                         # DEBUG !!
    local prog prog_path=''
    for prog; do
        prog_path="$(type -p "$prog" 2>/dev/null)" && break
    done
    [ -n "$prog_path" ] ||      # exit status of 0 or 1
        printf -- '%s' "$prog_path" # exit status 0=true
}

option_arg() {
    case "$1" in
        --dryrun) set_param Dry_Run 'true' ;;
        --help) set_param Give_Help 'true' ;;
        --verbose) set_param Verbose 'true' ;;
        *) return 1 ;;
    esac
    return 0
}

do_suss_options() {
    local this=do_suss_options
    local arg
    set_param Dry_Run 'false'
    set_param Give_Help 'false'
    set_param Verbose 'false'
    set_param Pattern 'unknown'
    # Consider making this a command-line option instead!!
    set_param Build_Shell "$(try_find_prog_path dash sh)" ||
        error "`cr 24 353 $this`" "can't suss Build_Shell"
    set_final Build_Shell;

    # record options and save non-option arguments
    declare -g Pgm_Args=( )                        # Non-Option args
    for arg; do
        option_arg "$arg" || Pgm_Args+=("$arg")
    done

    # if asked or if no non-option arguments, give full help
    { "$Give_Help" || [ ${#Pgm_Args[@]} -eq 0 ]; } && { give_full_help; exit 0; }
    return 0
}

# ** Determine Argument Patterns and Finalize Globals

# Roadmap item for targeted --help !!
# Once a pattern is sussed or while it's being sussed
# When the --help option was given
# Explain the pattern and exit 0

# *** tarball pattern

try_tarball() {
    local this='try_tarball'
    [ $# -gt 0 ] && [ $# -le 2 ] || return 1
    [ -f "$1" ] || return 1
    [ $# -eq 1 ] || expect_dir "$2" "`cr 25 380 $this`"
    local f1=${1##*/} # without the path
    local f2=${f1%.*} # without last extension
    local f           # trial project name
    case "$f1" in
        (*.tar) f=$f2 ;;
        (*.tar.*) f=${f2%.*} ;;
        (*) return 1;;
    esac
    set_final Pattern 'tarball' # commit to pattern
    # further deviations will be errors
    local v=${f##*-}            # trial version string
    local regexp_pattern='[1-9][0-9]?.[0-9][0-9]?(rc)?'
    [[ "$v" =~ $regexp_pattern ]] ||
        error "`cr 26 394 $this`" "unknown version pattern in $f"
    # We're satisfied, so
    set_final Archive $(realpath "$1")
    set_final Version "$v"
    [ $# = 2 ] && set_final Build_Grandparent_Dir "$(realpath "$2")"
    expect_dir "$Build_Grandparent_Dir" "`cr 27 399 $this`"
    return 0
}

# *** other patterns

try_version_git() {
    local this='try_version_git'
    set_final Pattern 'tarball'
    report -apology "`cr 28 408 $this`" "$Pattern pattern not yet implemented"
    return 1
}

try_bare_version() {
    local this='try_bare_version'
    set_final Pattern 'version'
    context_level_report "`cr 29 415 $this`" apology "$Pattern pattern not yet implemented"
    return 1
}

# *** determine install pattern

do_suss_args() {
    local this=do_suss_args

    try_tarball "$@" || try_version_git "$@" || try_bare_version "$@" ||
        error "`cr 30 425 $this`" 'unrecognized install pattern'

    [ -n "$Version" ] ||
        error "`cr 31 428 $this`" "Failed to suss a version"
}

# *** Try to find tcl library

do_try_find_tcl() {
    local tcl this=do_try_find_tcl
    for tcl in /usr/{lib,lib64}{,/tcl*}/tclConfig.sh
    do
        [ -f "$tcl" ] && break
    done
    if [ -f "${tcl:-}" ]; then
        with_tcl="--with-tclconfig=${tcl%/*}"
    else
        with_tcl=''
        report -warning "`cr 32 443 $this`" "Can't find tcl, will proceed without it!!"
    fi
}

# ** Prepare, Configure, Build, Install

# *** su commands

# su_acct_dir_cmd [CONTEXT] account directory command...
su_acct_dir_cmd() {
    local cxt=''                # will grow
    is_cs "$1" && { cxt="$1"; shift; }
    local acct="$1" dir="$2";  shift 2
    # abuse our knowledge of ContextSeqence representation and watch out:
    # - spaces or colons in the variables will produce a messy report!
    cxt="$(cr acct = "$acct") $(cr dir = "$dir") $(cr shell = "$Build_Shell") $cxt"
    report -command "$cxt" "$*"
    "$Dry_Run" || su - "$acct" -s "$Build_Shell" -c "cd \"$dir\"; $*"
}

# *** Prepare Build Directory With Fresh Source

do_prepare_build_dir() {
    local this=do_prepare_build_dir

    case "$Pattern" in
        (tarball)
        set_param Source_Dir "$Build_Parent_Dir/$Source_Name"
        ensure_dir "$Source_Dir" "$Build_Acct" "$Build_Group"  "`cr 33 471 $this`" 
        report -command "`cr 34 472 $this`" chown -R "$Build_Acct:$Build_Group" "$Build_Dir"
        chown -R "$Build_Acct:$Build_Group" "$Build_Parent_Dir"
        local cxt1="`cr 35 474 $this`"
        "$Dry_Run" ||
            su_acct_dir_cmd "$cxt1" "$Build_Acct" "$Build_Parent_Dir" \
                            tar xf - "$Archive" || error "$cxt1" "Can't extract $Archive"
        "$Dry_Run" || ! empty_dir "$Source_Dir"  ||
            expect_dir "$Source_Dir" "`cr 36 479 $this`"
        local cxt2="`cr 37 480 $this`"
        "$Dry_Run" ||
            su_acct_dir_cmd "$cxt2" "$Build_Acct" "$Build_Parent_Dir" \
                            tar cf - "$Source_Name" |
                su_acct_dir_cmd "$cxt2" "$Build_Acct" "$Build_Dir" \
                                tar xf - || error "$cxt2" "Can't copy $Archive"
        ;;
        (*) error "`cr 38 487 $this`" "unimplemented pattern $Pattern" ;;
    esac
    return 0
}

# *** Logging Functions

set_phase() {
    declare -g Phase="$1"
    declare -g Log_File="$Build_Dir/LOG_$Phase.org"
    touch "$Log_File"
    chown -R "$Build_Acct:$Build_Group" "$Log_File"

    { printf -- '%s -*- mode: %s; -*-\n' '' Org
      printf -- '#+%s: %s\n' TITLE 'PostgreSQL for Wicci Installation Log'
      printf -- '#+%s: %s\n' DATE "$(date)"
      printf -- '\n'
    } >> "$Log_File"

    [ "${#Early_Globals[@]}" -gt 0 ] && {
        declare -g Verbose
        local verbose="$Verbose"
        report "* Early Globals"
        report "`cr 39 510 $Phase`" "Arguments: ${Pgm_Args[*]}"
        report "`cr 40 511 $Phase`" "Initial Globals:\n"
        report_params "${Early_Globals[@]}"
        declare -g Early_GLobals=( )
        Verbose="$verbose"
    }

    report '' "* Phase $Phase"
}

# Using awk
# log stdin content, if any, as an OrgMode example block
log_example() {
    awk -v b='#+begin_example' -v e='#+end_example' \
        'NR==1{print b}NR>0{print}END{if (NR>0) print e}' | tee -a "$Log_File"
}

# log_error CONTEXT REPORT...
log_error() {
    local code=$(get_exit_code "$1")
    report -error "@"
    exit "$code"
}

# *** Phase CONFIG

do_config() {
    local this=do_config

    set_phase CONFIG

    set_param Source_Root "$Build_Dir/$Source_Name"
    ensure_dir "$Source_Root" "$Build_Acct" "$Build_Group"  "`cr 41 542 $this`" 

    # disable shellcheck wanting quotes around $with_tcl
    # shellcheck disable=SC2206
    declare -g Config_Options=(
        --with-libxml
        --with-libxslt
        --enable-debug
        --enable-cassert
        $with_tcl                   # don't quote!
        "--prefix=$PG_Dir"
    )

    $Verbose && report_param_array Config_Options

    local cxt="`cr 42 557 $this`"
    su_acct_dir_cmd "$cxt" "$Build_Acct" "$Source_Root" ./configure "${Config_Options[*]}" |
        log_example || log_error "$cxt" "./configure -> $?"
}

# *** Phases BUILD and INSTALL

do_build() {
    local this=do_build

    set_phase BUILD

    local cxt="`cr 43 569 $this`"
    su_acct_dir_cmd "$cxt" "$Build_Acct" "$Source_Root" make |
        log_example || log_error "$cxt" "make -> $?"
}

do_install() {
    local this=do_install

    set_phase INSTALL

    local cxt="`cr 44 579 $this`"
    su_acct_dir_cmd "$cxt" "$Build_Acct" "$Source_Root" make install |
        log_example || log_error "$cxt" "make install -> $?"
}

# *** BUILD and INSTALL Some Contributed Modules

do_build_install_contribs() {
    local d this=do_build_install_contribs

    set_final Contrib_Dir "$Source_Root/contrib"
    expect_dir "$Contrib_Dir" "`cr 45 590 $this`"

    for d in xml2 intarray citext hstore
    do
        set_phase $d-BUILD
        local cxt1="`cr 46 595 $this`"
        su_acct_dir_cmd "$cxt1" "$Build_Acct" "$Contrib_Dir" make |
            log_example || error "$cxt1" "make -> $?"

        set_phase $d-INSTALL
        local cxt2="`cr 47 600 $this`"
        su_acct_dir_cmd "$cxt2" "$Build_Acct" "$Contrib_Dir" make install |
            log_example || error "$cxt2" "make install -> $?"
    done
}

# ** Setting Up Postgres
# *** Procedures to run as Postgres

# pg_cmd [CONTEXT] command...
pg_cmd() {
    local cxt=''
    is_cs "$1" && { cxt="$1"; shift; }
    su_acct_dir_cmd "$cxt" "$PG_Acct" "$PG_Dir" "bin/$*" | log_example
}

# pg_data_cmd [CONTEXT] command...
pg_data_cmd() {
    local cxt=''
    is_cs "$1" && { cxt="$1"; shift; }
    local cmd="$1"; shift
    pg_cmd "$cxt" "$cmd" -D "$PG_Data" "$@"
}

# try [CONTEXT] COMMAND...
try() {
    local cxt=''
    is_cs "$1" && { cxt="$1"; shift; }
    report -command "$cxt" "$@"
    "$@" | log_example || error "$cxt" "$Phase $1 -> $?"
}

# *** Initializing Postgres

do_init_pg() {
    local this=do_init_pg
    ensure_dir "$PG_Data" "$PG_Acct" "$PG_Group" "`cr 48 636 $this`"
    try "`cr 49 637 $this`" empty_dir "$PG_Data"
    try "`cr 50 638 $this`" chmod 700 "$PG_Data"
    # Change whole install area ownership from Build_Acct to PG_Acct
    try "`cr 51 640 $this`" chown -R "$PG_Acct:$PG_Group" "$PG_Dir"
    pg_data_cmd "`cr 52 641 $this`" initdb ||
        error "`cr 53 642 $this`" "initdb -> $?"
    # we should take care of this: !!
    report "`cr 54 644 $this`" "-remember to" \
           "ln -s XFiles directory to $PG_Data"
}

# *** Starting the Server

do_start_pg() {
    local this=do_start_pg
    # Check if there's an existing PostgreSQL running
    # and do something appropriate if there is!!

    # start the PostgreSQL server
    pg_data_cmd "`cr 55 656 $this`" "pg_ctl -l $PG_Log" start ||
        error "`cr 56 657 $this`" "starting server -> $?"
    sleep 5	# seems to need a moment to get ready
}

# *** Configuring PostgreSQL

# add additional languages to database template1
do_add_langs() {
    local this=do_add_langs
    local lang langs='pltcl'
    set_param PG_Problem_Count  # might already exist, otherwise now 0
    for lang in $langs; do
        # try $PG_Bin/createlang "$lang" template1
        printf -- "create trusted procedural language '%s';\n" "$lang" |
            pg_cmd "`cr 57 671 $this`" psql -a template1 || {
            report "`cr 58 672 $this`" "createlang $lang -> $?"
            let ++PG_Problem_Count
        }
    done
}

# try to create some databases
do_create_databases() {
    local db this=do_create_databases
    for db in wicci1
    do
        pg_cmd "`cr 59 683 $this`" createdb "$db" || {
            report "`cr 60 684 $this`" "createdb $db -> $?"
            let ++PG_Problem_Count
        }
    done
}

do_manage_pg_config_file() {
    local this=do_manage_pg_config_file
    pg_cmd "`cr 61 692 $this`" mv "$PG_Conf" "$PG_Conf_Orig" ||
        report "`cr 62 693 $this`" "mv ${PG_Conf##*/} -> $?"
    pg_cmd "`cr 63 694 $this`" cp "$PG_Conf_Orig" "$PG_Conf" ||
        report "`cr 64 695 $this`" "cp ${PG_Conf##*/} -> $?"
    # we should take care of this: !!
    report "`cr 65 697 $this`" '-remember to' \
           'add Make/wicci1 to dynamic_library_path'
    # and any other typical changes
}

# create some PostgreSQL superusers
# these should really come from the command line or a config file!!
# and/or default to the real-user-id
do_create_superusers() {
    local users this=do_create_superusers

    echo -n 'Who should we make be PostgreSQL superuser(s)? '
    read users -r
    for user in $users; do
        { user_exists "$user" && pg_cmd "`cr 66 711 $this`" createuser --superuser "$user"; } ||
                report "`cr 67 712 $this`" "createuser $user -> $?"
    done
}

# ** Putting it all together

# We need a mechanism for skipping doing a reasonable subset of the steps

# Store script OPTIONS as parameter values
# put regular options into global array Pgm_Args
do_suss_options "$@"
set -- "${Pgm_Args[@]}"      # options now gone from "$@"

test root = "`whoami`" || error "`cr 68 725 "$Pgm_Name"`" "Must run as root!"
do_suss_args "$@"
do_suss_build_dirs "$Version"
do_suss_pg_dirs "$Version"

# Find location of special libraries
do_try_find_tcl

do_prepare_build_dir

set_phase POSTGRES

declare -g PG_Problem_Count=0

do_init_pg
do_start_pg
do_add_langs
[ "$PG_Problem_Count" -eq 0 ] && do_create_databases
do_manage_pg_config_file
do_create_superusers

echo "Configure $PG_Conf, etc.  For the Wicci:
(1) add the Make/wicci1 directory to dynamic_library_path'
(2) symlink the XFiles directory to the PostgreSQL data directory
Restart the server and Have Fun!"
