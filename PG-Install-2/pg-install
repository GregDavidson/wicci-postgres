#!/usr/bin/bash

# * Install PostgreSQL for the Wicci

# ** Some Initial Words

# Run this script with no arguments for help!

# All action is orchestrated at the end of the script
# by calling the functions whose names begin with do_

# Note: =Emacs= =outshine-mode= lets you treat this file as a hierarchical
# document. TAB on comment lines beginning with asterisks will hide/show nodes
# much like with =OrgMode=.

# Turn on tracing before troublesome code
# set -vx                         # DEBUG !!
# Turn off tracing following troublesome code
# set +vx                         # DEBUG !!

# ** A Few Initial Settings

# exit on command failures
# set -e
# is currently commented out as some of our functions "fail"!
# Research this as it would be nice to reinstate this protection!
# Possibly we're lacking a few strategic
#   return 0 # as last statement in a function
#   || true  # at end of an expression
# - but don't add these gratuitously or you'll conceal errors!
# Note that vaiable settings don't change exit status, so
#   COMMAND || VARIABLE-SETTING
# Should be rewritten as
#   COMMAND || VARIABLE-SETTING || true

set -u                          # exit when referencing undefined variables
set -o pipefail                 # capture last non-zero status in pipeline

readonly Pgm_Name="${0##*/}"    # Name of this script
readonly Pgm_Dir="$(realpath "$(dirname "$0")")"
readonly Profile_Default="$Pgm_Dir/$Pgm_Name-profile.bash"

# Early_Globals will be logged once logging is available
declare -a Early_Globals=(Pgm_Name Pgm_Dir)

# ** Usage Help

# *** Array Length Checking

eq_array_lengths() {
    local n0="$1"; shift        # save first array name
    local -n a0="$n0"           # alias first array
    local n; for n; do          # loop through all other names
        local -n a="$n"         # alias
        [ "${#a[@]}" -eq "${#a0[@]}" ] || { # lengths match or
            >&2 printf '%s[%d] != %s[%d]!\n' "$n" "${#a[@]}"  "$n0" "${#a0[@]}"
            exit 1
        }
    done
}

# *** Describing Usage

# How this script can be used

declare -r Options=('--help' '--dryrun' '--verbose' '--profile=BASH_SCRIPT')
declare -r Options_Params=('Give_Help' 'Dry_Run' 'Verbose' 'Profile')
declare -ra Options_Explanations=(
    'give help'
    'go through the motions without doing much'
    'send reports to the terminal in addition to the logfile'
    "source script before orchestration, default ${Profile_Default#$Pgm_Dir/}"
)

eq_array_lengths Options Options_Params Options_Explanations

declare -rA Patterns=( [help]=0 [tarball]=1 [git-dir]=2 [src-dir]=3 )

# In array Arg_Patterns, note Posix documentation convention
# of optional arguments in [square brackets]
declare -ra Arg_Patterns=(
''
'PATH-TO-TARBALL [PARENT-INSTALL-DIR]'
'VERSION POSTGRESQL-GIT-REPOSITORY [PARENT-INSTALL-DIR]'
'VERSION [PARENT-INSTALL-DIR]'
)
declare -ra Arg_Pattern_Explanations=(
'give help'
'install from tar archive'
'install specified version from git repository'
'install specified version from existing source'
)

eq_array_lengths Patterns Arg_Patterns Arg_Pattern_Explanations

declare -ra Caveats=(
    'Currently needs to run as root.'
    'Unmet dependencies should cause it to abort.'
    'Logs and work done so far left for you to examine.'
    'Too many assumptions for any hard guarantees!'
    'May behave arbitrarily badly in unfamiliar environment.'
)

# *** give_full_help

give_full_help() {
    local i
    printf -- '* Calling Patterns:\n'
    for i in ${!Arg_Patterns[@]}; do
        printf -- '%s %s\n- %s\n' \
               "$Pgm_Name" "${Arg_Patterns[$i]}" \
               "${Arg_Pattern_Explanations[$i]}"
    done
    printf -- '* Options:\n'
    for i in ${!Options[@]}; do
        printf -- '%s -- %s\n' "${Options[$i]}" "${Options_Explanations[$i]}" 
    done
    printf -- '* Caveats:\n'
    for i in ${!Caveats[@]}; do
        printf -- '- %s\n' "${Caveats[$i]}"
    done
}

# ** Reporting, Context, Logging, Setting Parameters

# Reports will go to $Log_File once it has a value
declare -g Log_File             # no value yet!

# And Reports will go to stderr or stdout
# - when Log_File is NOT set
# - when Verbose = true

# *** Context for Reports

# Context is everything! Reports, including Warnings and Error Messages need to
# report context. A ContextSequence is a space-separated string consisting of a
# ContextRecords. A ContextRecord is a colon (:) separated record of an
# ExitCode, LineNumber and optional entities such as FunctionNames and
# ParameterSettings - which must not contain either spaces or colons. These
# ContextSequences generally grow as they're passed as FunctionArguments.
# ExitCodes and LineNumbers are generally computed by a tool.

# cs makes context sequences
# cs existing-context-sequence context-record-arguments
cs() {
    cs0="$1"; shift
    printf -- '%s%s%s' "$(cr "$@")" "${cs0:+ }" "$cs0"
}

# cr makes ContextRecords which are also ContextSequence singletons
# cr exit_code line_number [entity...]
cr() {
    local IFS=':'
    printf -- '%s' "$*"
}

# burst a ContextRecord into space-separated fields
cr_burst() {
    local IFS=':'
    local fields
    read -ra fields <<< "$1"
    IFS=' '
    printf -- '%s' "${fields[*]}"
}

# test whether the argument appears to be a ContextSequence
is_cs() {
    [ -z "$1" ] || [[ "X$1" =~ ^X[0-9]+: ]]
}

# cs_code_maybe [CONTEXT]
# returns the first ExitCode in the ContextSequence
# - default to 9 if none is specified by the context
# - ( generated ExitCodes begin with 10 )
cs_code_maybe() {
    local context="${1:-}"                  # default to empty context
    local code="${context%%[!0-9]*}"         # strip starting with 1st non-digit
    printf -- "%d" "${code:-9}"             # return the code to use
    # verbose workaround to having a command fail
    # [ -n "$code" ] # might trip -e
    # workaround:
    if [ -n "$code" ]; then return 0; else return 1; fi
}

# *** Reporting

# report_out [-LEVEL] [CONTEXT] [FORMAT] REPORT...
# All report messages go through here.
# Formats should work well with OrgMode.
# Currently any supplied FORMAT option is ignored.
report_out() {
    local level='' context='' format='' cr
    # get the "level", if any
    [[ "X$1" =~ ^X- ]] && {
        level="${1#-}"          # strip initial -
        shift                   # drop argument
    }
    # get the context, if any
    is_cs "$1" && { context="$1"; shift; }
    # get the "format", if any
    case "$1" in
        (:*|-:*) format="$1" ; shift ;;
    esac
    # make the main report
    case "$level" in
        ?*) # OrgMode definition-list format when level non-empty
            printf -- '- %s :: %s\n' "$level" "$*" ;;
        *)  # no format applied when level is empty
            printf -- '%s\n' "$*" ;;
    esac
    # follow with all supporting context
    for cr in $context; do
        printf -- '- context: %s\n' "$(cr_burst "$cr")"
    done
}

# same interface as report_out
# report to stdout if Verbose or no Log_File
# report to Log_File if it exists
report() {
    { "${Verbose:-false}" || [ -z "${Log_File:-}" ]; } && report_out "$@"
    [ -n "${Log_File:-}" ] && report_out "$@" >> "$Log_File"
}

# error [CONTEXT] REPORT...
error() {
    local code=$(cs_code_maybe "$1")
    >&2 report -error "$@"
    exit "$code"
}

# *** Setting and Reporting Global Parameters

# Use these functions to set global parameters
# so that the settings get reported!

# report_param global_parameter
report_param() {
    local -n p="$1"     # alias p to the parameter
    report -"\$$1" '' "$p"
}

# report_param global_array_parameter
report_param_array() {
    local -n a="$1"     # alias a to the array
    local i
    report -"$1[]" '' Elements
    for i in ${!a[@]}; do
        report -"[$i]" '' "${a[$i]}"
    done
}

# report_params PARAMETER...
report_params() {
    local p; for p; do report_param "$p"; done
}

# set_param_silently global_parameter [value]
set_param_silently() {
    { [ $# -ge 1 ] && [ $# -le 2 ]; } ||
        error "set_param given $# arguments"
    declare -g "$1"             # declare as global parameter
    [ $# -eq 1 ] && return 0
    local -n param="$1"         # alias as param
    # shellcheck disable=SC2034
    param="$2"                  # set its value
}

# set_param global_parameter [value]
set_param() {
    set_param_silently "$@"
    report_param "$1" # report it
    # if report couldn't log it, record it for later
    [ -n "${Log_File:-}" ] || Early_Globals+=("$1")
}

# set_final global_parameter [value]
set_final() {
    set_param "$@"
    declare -gr "$1"            # declare as global readonly
}

# ** Set Accounts and Locations

# Using grep
# Assumes FILE is Posix /etc/passwd or /etc/group
# user_group_exists NAME 'user|group' FILE [CONTEXT]
user_group_exists() {
    local context="${4:-}"
    grep -qs "^$1:" "$3" || error "$context" "No $2 $1 in $3"
    printf -- '%s' "$1"            # return value
}
# user_exists USER-NAME [CONTEXT]
user_exists() { user_group_exists "$1" 'user' '/etc/passwd' "${2:-}"; }
# group_exists GROUP-NAME [CONTEXT]
group_exists() { user_group_exists "$1" 'group' '/etc/group' "${2:-}"; }

do_set_accounts() {
    local this=do_suss_accounts

    # The Account and Group which we use to configure and build PostgreSQL
    set_final Build_Acct "$(user_exists bin "`cr 10 303 $this`")"
    set_final Build_Group "$(group_exists bin "`cr 11 304 $this`")"
    # The Account and Group which owns the installed PostgreSQL
    set_final PG_Acct "$(user_exists postgres "`cr 12 306 $this`")"
    set_final PG_Group "$(group_exists postgres "`cr 13 307 $this`")"
}

do_set_locations() {
    local this=do_suss_locations

    set_final Build_Grandparent_Dir /usr/local/src
    [ -d "$Build_Grandparent_Dir" ] ||
        error "`cr 14 315 $this`" expected directory "$Build_Grandparent_Dir"

    for d in /usr/local/SW.d /usr/local/SW /usr/local; do
        [ -d "$d" ] && break
    done
    [ -d "$d" ] || error "`cr 15 320 $this`" "expected PG_Parent_Dir $d"
    set_final PG_Parent_Dir "$d"
    : "${Profile:=}"            # if unset, set to empty string
    [ -z "${Profile}" ] || ! [ -f "$Profile_Default" ] || \
        set_final Profile "$Profile_Default"
    [ -z "${Profile}" ] || [ -f "$Profile" ] || \
        error "`cr 16 326 $this`" expected Profile script "$Profile"
}

# ** Process Command Line Options

# Find the path to a program with fallbacks, or fail
# prog_path_maybe PROGRAM_NAME...
prog_path_maybe() {
    # set -vx                         # DEBUG !!
    local prog path=''
    for prog; do
        path="$(type -P "$prog" 2>/dev/null)" && break
    done
    [ -n "$path" ] || return 1
    printf -- '%s' "$path"
}

# option_key --foo=bar ==> --foo
option_key() {
    printf '%s' "${1%%=*}"
}

# option_val_maybe --foo=bar ==> bar
# fails and returns '' when no val
option_val_maybe() {
    local name="${1##*=}"       # strip up to = if any
    [ "X$name" != "X$1" ] || return 1
    printf '%s' "$name"
}

declare -A Options_Index

option_maybe() {
    [[ "X$1" =~ ^X--[a-zA-Z_]+=? ]] || return 1
    local key="$(option_key "$1")" val="$(option_val_maybe "$1")"
    local i="${Options_Index["$key"]}"
    [ -n "$i" ] || return 1
    local option="${Options["$i"]}"
    local param="${Options_Params["$i"]}"
    case "$option" in
        (--verbose)    # Evil Kludgy Patch:
            # Verbose temporarily false while reporting Early_Globals
            # if reported will have wrong value :-(
            # so don't use set_final -- hang head in shame!!!
            declare -g Verbose='true' ;;
        ("${key}"=*) set_final "$param" "$val" ;; # value parameter
        ("${key}") set_final "$param" true ;;        # boolean parameter
        (*) >&2 echo "option_arg: impossible option $option"
            exit 1 ;;
    esac
    return 0
}

# Option[i]=--foo ==> Options_Index[--foo]=i
# Option[i]=--foo=bar ==> Options_Index[--foo]=i
index_options() {
    local i option key val
    for i in ${!Options[@]}; do
        option="${Options[$i]}"
        key="$(option_key "$option")"
        val="$(option_val_maybe "$option")" || true
        Options_Index["$key"]=$i
    done
}

set_option_defaults() {
    local i
    for i in "${!Options[@]}"; do
        local param="${Options_Params[$i]}" # associated parameter
        case "${Options[$i]}" in
            (*=*) set_param_silently "$param" '' ;;    # value default
            (*) set_param_silently "$param" 'false' ;; # boolean default
        esac
    done
}

do_suss_options() {
    local this=do_suss_options
    local arg
    index_options
    set_option_defaults
    declare -g Pattern='unknown'
    # Consider making this a command-line option instead!!
    set_param Build_Shell "$(prog_path_maybe dash sh)" ||
        error "`cr 17 413 $this`" "can't suss Build_Shell"
    set_final Build_Shell;

    # record options and save non-option arguments
    declare -g Pgm_Args=( )                        # Non-Option args
    for arg; do
        option_maybe "$arg" || Pgm_Args+=("$arg")
    done

    "$Give_Help" && { give_full_help; exit 0; }
    return 0
}

# ** Suss Argument Pattern to Finalize Globals

# Roadmap item for targeted --help !!
# Once a pattern is sussed or while it's being sussed
# When the --help option was given
# Explain the pattern and exit 0

# *** Tarball Pattern

try_tarball() {
    local this='try_tarball'
    [ $# -gt 0 ] && [ $# -le 2 ] || return 1
    [ -f "$1" ] || return 1
    [ $# -eq 1 ] || expect_dir "$2" "`cr 18 439 $this`"
    local f1=${1##*/} # without the path
    local f2=${f1%.*} # without last extension
    local f           # trial project name
    case "$f1" in
        (*.tar) f=$f2 ;;
        (*.tar.*) f=${f2%.*} ;;
        (*) return 1;;
    esac
    set_final Pattern 'tarball' # commit to pattern
    # further deviations will be errors
    local v=${f##*-}            # trial version string
    local regexp_pattern='[1-9][0-9]?.[0-9][0-9]?(rc)?'
    [[ "$v" =~ $regexp_pattern ]] ||
        error "`cr 19 453 $this`" "unknown version pattern in $f"
    # We're satisfied, so
    set_final Archive "$(realpath "$1")"
    set_final Version "$v"
    [ $# = 2 ] && set_final Build_Grandparent_Dir "$(realpath "$2")"
    expect_dir "$Build_Grandparent_Dir" "`cr 20 458 $this`"
    return 0
}

# *** Other Patterns

try_version_git() {
    local this='try_version_git'
    set_final Pattern 'tarball'
    report -apology "`cr 21 467 $this`" "$Pattern pattern not yet implemented"
    return 1
}

try_bare_version() {
    local this='try_bare_version'
    set_final Pattern 'version'
    context_level_report "`cr 22 474 $this`" apology "$Pattern pattern not yet implemented"
    return 1
}

# *** Determine Install Pattern

do_suss_args() {
    local this=do_suss_args

    try_tarball "$@" || try_version_git "$@" || try_bare_version "$@" ||
        error "`cr 23 484 $this`" 'unrecognized install pattern'

    [ -n "$Version" ] ||
        error "`cr 24 487 $this`" "Failed to suss a version"
}


# *** Given Version, Finalize Build and PG Dirs

# Using ls, grep
# empty_dir() { ! [ -e "$1" ] || [ -d "$1"] && ! ls -qAH -- "$1" | grep -q .; }
# just using bash builtin features
empty_dir() {
    ! [ -e "$1" ] || [ -d "$1" ] && ! [[ $(shopt -s nullglob dotglob; echo "$1"/*) ]];
}

# expect_dir PATH [CONTEXT]
expect_dir() {
    [ -d "$1" ] || error "${2:-}" "Expected directory $1"
}

# Using mkdir, chown
# ensure directory exists at PATH or mkdir and chown it
# ensure_dir PATH ACCOUNT GROUP [CONTEXT]
ensure_dir() {
    local dir="$1" acct="$2" group="$3" cxt="${4:-}"
    [ -d "$dir" ] || {
        [ -e "$dir" ] &&          # whoops, something else there!
            error "$cxt" "Expected directory $dir"
        report -command "$cxt" mkdir -p "$dir"
        mkdir "$dir"
        report -command "$cxt" chown "$acct:$group" "$dir"
        chown "$acct:$group" "$dir"
    }
}

# when we know the version, create the build directories
# do_suss_build_dirs VERSION
do_suss_build_dirs() {
    local this=do_suss_build_dirs
    set_final Project_Name "PostgreSQL-$1"
    set_final Source_Name "${Project_Name,,}" # lower case
    set_final Build_Parent_Dir "$Build_Grandparent_Dir/$Project_Name"
    ensure_dir "$Build_Parent_Dir" "$Build_Acct" "$Build_Group" "`cr 25 527 $this`"
    local n=1 d
    while d="$Build_Parent_Dir/Attempt-$n" ; ! empty_dir "$d"; do
        let ++n
    done
    set_final Build_Dir "$d"
    ensure_dir "$Build_Dir" "$Build_Acct" "$Build_Group" "`cr 26 533 suss_build_dirs`"
}

# when we know the version, create the PG Dirs
# Initially they'll be owned by the $Build_Acct
# Later they'll be =chown=ed to the $PG_Acct
# do_suss_pg_dirs VERSION
do_suss_pg_dirs() {
    local this=do_suss_pg_dirs
    set_final PG_Dir "$PG_Parent_Dir/pgsql-$1"
    local n=1 old
    [ -d "$PG_Dir" ] && ! empty_dir "$PG_Dir" && {
            while old="$PG_Dir-$n"; [ -d "$old" ]; do
                let ++n
            done
            report -"install conflict warning" "`cr 27 548 $this`" \
                   mv "$PG_Dir" "$old"
            mv "$PG_Dir" "$old"
        }
    ensure_dir "$PG_Dir" "$Build_Acct" "$Build_Group" "`cr 28 552 $this`"
    set_final PG_Bin "$PG_Dir/bin"
    set_final PG_Data "$PG_Dir/data"
    set_final PG_Log "$PG_Data/logfile"
    set_final PG_Conf "$PG_Data/postgresql.conf"
    set_final PG_Conf_Orig "$PG_Conf-$Version"
}

# ** Prepare, Configure, Build, Install

# *** su commands

# su_acct_dir_cmd [CONTEXT] account directory command...
# use this one when you musn't add anything to stdout
su_acct_dir_cmd() {
    local cxt=''                # will grow
    is_cs "$1" && { cxt="$1"; shift; }
    local acct="$1" dir="$2";  shift 2
    # abuse our knowledge of ContextSeqence representation and watch out:
    # - spaces or colons in the variables will produce a messy report!
    cxt="$(cr 1 acct = "$acct") $(cr 2 dir = "$dir") $(cr 3 shell = "$Build_Shell") $cxt"
    >&2 report -command "$cxt" "$*"
    "$Dry_Run" || su - "$acct" -s "$Build_Shell" -c "cd \"$dir\"; $*"
}

# su_acct_dir_cmd_log [CONTEXT] account directory command...
su_acct_dir_cmd_log() {
    local cxt=''                # will grow
    is_cs "$1" && { cxt="$1"; shift; }
    local acct="$1" dir="$2";  shift 2
    # abuse our knowledge of ContextSeqence representation and watch out:
    # - spaces or colons in the variables will produce a messy report!
    cxt="$(cr 1 acct = "$acct") $(cr 2 dir = "$dir") $(cr 3 shell = "$Build_Shell") $cxt"
    report -command "$cxt" "$*"
    "$Dry_Run" || su - "$acct" -s "$Build_Shell" -c "cd \"$dir\"; $*" | log_example
}

# *** Prepare Build Directory With Fresh Source

do_prepare_build_dir() {
    local this=do_prepare_build_dir

    case "$Pattern" in
        (tarball)
        set_param Source_Dir "$Build_Parent_Dir/$Source_Name"
        ensure_dir "$Source_Dir" "$Build_Acct" "$Build_Group" \
                   "`cr 29 598 $this`"
        report -command "`cr 30 599 $this`" \
               chown -R "$Build_Acct:$Build_Group" "$Build_Dir"
        chown -R "$Build_Acct:$Build_Group" "$Build_Parent_Dir"
        local cxt1="`cr 31 602 $this`"
        su_acct_dir_cmd "$cxt1" "$Build_Acct" "$Build_Parent_Dir" \
                        tar xf "$Archive" ||
            error "$cxt1" "Can't extract $Archive"
        "$Dry_Run" || ! empty_dir "$Source_Dir"  ||
            expect_dir "$Source_Dir" "`cr 32 607 $this`"
        su_acct_dir_cmd "`cr 33 608 $this`" "$Build_Acct" "$Build_Parent_Dir" \
                        tar cf - "$Source_Name" |
            su_acct_dir_cmd "`cr 34 610 $this`" "$Build_Acct" "$Build_Dir" \
                            tar xf - ||
            error "`cr 35 612 $this`" "Can't copy $Source_Dir to $Build_Dir"
        ;;
        (*) error "`cr 36 614 $this`" "unimplemented pattern $Pattern" ;;
    esac
    return 0
}

# *** Logging Functions

set_phase() {
    declare -g Phase="$1"
    declare -g Log_File="$Build_Dir/LOG_$Phase.org"
    touch "$Log_File"
    chown -R "$Build_Acct:$Build_Group" "$Log_File"

    { printf -- '%s -*- mode: %s; -*-\n' '' Org
      printf -- '#+%s: %s\n' TITLE 'PostgreSQL for Wicci Installation Log'
      printf -- '#+%s: %s\n' DATE "$(date)"
      printf -- '\n'
    } >> "$Log_File"

    [ "${#Early_Globals[@]}" -gt 0 ] && {
        declare -g Verbose
        local verbose="$Verbose"
        Verbose='false'
        report '' '* Early Globals:'
        report -'Pgm_Args[]' "${Pgm_Args[*]}"
        report_params "${Early_Globals[@]}"
        Early_Globals=( )
        Verbose="$verbose"
    }

    report '' "* Phase $Phase"
}

# Using awk
# log stdin content, if any, as an OrgMode example block
log_example() {
    awk -v b='#+begin_example' -v e='#+end_example' \
        'NR==1{print b}NR>0{print}END{if (NR>0) print e}' | tee -a "${Log_File:-/dev/null}"
}

# log_error CONTEXT REPORT...
log_error() {
    local code=$(cs_code_maybe "$1")
    report -error "@"
    exit "$code"
}

# *** Phase CONFIG

do_config() {
    local this=do_config

    set_phase CONFIG

    set_param Source_Root "$Build_Dir/$Source_Name"
    ensure_dir "$Source_Root" "$Build_Acct" "$Build_Group"  "`cr 37 669 $this`" 

    # disable shellcheck wanting quotes around $with_tcl
    # shellcheck disable=SC2206
    Config_Options+=(
        --with-libxml
        --with-libxslt
        --enable-debug
        --enable-cassert
        "--prefix=$PG_Dir"
    )

    $Verbose && report_param_array Config_Options

    local cxt="`cr 38 683 $this`"
    su_acct_dir_cmd_log "$cxt" "$Build_Acct" "$Source_Root" ./configure "${Config_Options[*]}" ||
        log_error "$cxt" "./configure -> $?"
}

# *** Phases BUILD and INSTALL

do_build() {
    local this=do_build

    set_phase BUILD

    local cxt="`cr 39 695 $this`"
    su_acct_dir_cmd_log "$cxt" "$Build_Acct" "$Source_Root" make ||
        log_error "$cxt" "make -> $?"
}

do_install() {
    local this=do_install

    set_phase INSTALL

    local cxt="`cr 40 705 $this`"
    su_acct_dir_cmd_log "$cxt" "$Build_Acct" "$Source_Root" make install ||
        log_error "$cxt" "make install -> $?"
}

# *** BUILD and INSTALL Some Contributed Modules

do_build_install_contribs() {
    local d this=do_build_install_contribs

    set_final Contrib_Dir "$Source_Root/contrib"
    expect_dir "$Contrib_Dir" "`cr 41 716 $this`"

    for d in xml2 intarray citext hstore
    do
        set_phase $d-BUILD
        local cxt1="`cr 42 721 $this`"
        su_acct_dir_cmd_log "$cxt1" "$Build_Acct" "$Contrib_Dir" make ||
            error "$cxt1" "make -> $?"

        set_phase $d-INSTALL
        local cxt2="`cr 43 726 $this`"
        su_acct_dir_cmd_log "$cxt2" "$Build_Acct" "$Contrib_Dir" make install ||
            error "$cxt2" "make install -> $?"
    done
}

# ** Setting Up Postgres
# *** Procedures to run as Postgres

# pg_cmd [CONTEXT] command...
pg_cmd() {
    local cxt=''
    is_cs "$1" && { cxt="$1"; shift; }
    su_acct_dir_cmd_log "$cxt" "$PG_Acct" "$PG_Dir" "bin/$*"
}

# pg_data_cmd [CONTEXT] command...
pg_data_cmd() {
    local cxt=''
    is_cs "$1" && { cxt="$1"; shift; }
    local cmd="$1"; shift
    pg_cmd "$cxt" "$cmd" -D "$PG_Data" "$@"
}

# try [CONTEXT] COMMAND...
try() {
    local cxt=''
    is_cs "$1" && { cxt="$1"; shift; }
    report -command "$cxt" "$@"
    "$@" || error "$cxt" "$Phase $1 -> $?"
}

# *** Initializing Postgres

do_init_pg() {
    local this=do_init_pg
    ensure_dir "$PG_Data" "$PG_Acct" "$PG_Group" "`cr 44 762 $this`"
    try "`cr 45 763 $this`" empty_dir "$PG_Data"
    try "`cr 46 764 $this`" chmod 700 "$PG_Data"
    # Change whole install area ownership from Build_Acct to PG_Acct
    try "`cr 47 766 $this`" chown -R "$PG_Acct:$PG_Group" "$PG_Dir"
    pg_data_cmd "`cr 48 767 $this`" initdb ||
        error "`cr 49 768 $this`" "initdb -> $?"
    # we should take care of this: !!
    report "`cr 50 770 $this`" "-remember to" \
           "ln -s XFiles directory to $PG_Data"
}

# *** Starting the Server

do_start_pg() {
    local this=do_start_pg
    # Check if there's an existing PostgreSQL running
    # and do something appropriate if there is!!

    # start the PostgreSQL server
    pg_data_cmd "`cr 51 782 $this`" "pg_ctl -l $PG_Log" start ||
        error "`cr 52 783 $this`" "starting server -> $?"
    sleep 5	# seems to need a moment to get ready
}

# *** Configuring PostgreSQL

# add additional languages to database template1
do_add_langs() {
    local this=do_add_langs
    local lang langs='pltcl'
    set_param PG_Problem_Count  # might already exist, otherwise now 0
    for lang in $langs; do
        # try $PG_Bin/createlang "$lang" template1
        printf -- "create trusted procedural language '%s';\n" "$lang" |
            pg_cmd "`cr 53 797 $this`" psql -a template1 || {
            report "`cr 54 798 $this`" "createlang $lang -> $?"
            let ++PG_Problem_Count
        }
    done
}

# try to create some databases
do_create_databases() {
    local db this=do_create_databases
    for db in wicci1
    do
        pg_cmd "`cr 55 809 $this`" createdb "$db" || {
            report "`cr 56 810 $this`" "createdb $db -> $?"
            let ++PG_Problem_Count
        }
    done
}

do_manage_pg_config_file() {
    local this=do_manage_pg_config_file
    pg_cmd "`cr 57 818 $this`" mv "$PG_Conf" "$PG_Conf_Orig" ||
        report "`cr 58 819 $this`" "mv ${PG_Conf##*/} -> $?"
    pg_cmd "`cr 59 820 $this`" cp "$PG_Conf_Orig" "$PG_Conf" ||
        report "`cr 60 821 $this`" "cp ${PG_Conf##*/} -> $?"
    # we should take care of this: !!
    report "`cr 61 823 $this`" '-remember to' \
           'add Make/wicci1 to dynamic_library_path'
    # and any other typical changes
}

# create some PostgreSQL superusers
# these should really come from the command line or a config file!!
# and/or default to the real-user-id
do_create_superusers() {
    local users this=do_create_superusers

    echo -n 'Who should we make be PostgreSQL superuser(s)? '
    read -r users
    for user in $users; do
        { user_exists "$user" && pg_cmd "`cr 62 837 $this`" createuser --superuser "$user"; } ||
                report "`cr 63 838 $this`" "createuser $user -> $?"
    done
}

# ** Putting it all together

# We need a mechanism for skipping doing a reasonable subset of the steps

[ $# -eq 0 ] && { give_full_help; exit 0; }

do_set_accounts
do_set_locations
# Store script OPTIONS as parameter values
# put regular options into global array Pgm_Args
do_suss_options "$@"
set -- "${Pgm_Args[@]}"      # options now gone from "$@"

test root = "`whoami`" || error "`cr 64 855 "$Pgm_Name"`" "Must run as root!"
do_suss_args "$@"

declare -g Config_Options

# Strategic place to source the Profile as it can
# override any and all of the sussed Parameters!
[ -f "${Profile}" ] && . "${Profile}"

do_suss_build_dirs "$Version"
do_suss_pg_dirs "$Version"

do_prepare_build_dir
do_config
do_build
do_install

do_build_install_contribs

set_phase POSTGRES

declare -g PG_Problem_Count=0

do_init_pg
do_start_pg
do_add_langs
[ "$PG_Problem_Count" -eq 0 ] && do_create_databases
do_manage_pg_config_file
do_create_superusers

echo "Configure $PG_Conf, etc.  For the Wicci:
(1) add the Make/wicci1 directory to dynamic_library_path
(2) symlink the XFiles directory to the PostgreSQL data directory
Restart the server and Have Fun!"


# ** Some Final Words

# This script is limited and fragile. There should be another file, possibly
# named pg-install.org which describes this script's infelicities and
# development roadmap in more detail.

# I've used the shellcheck program to help catch mistakes
# with these .shellcheckrc settings:
#	# accept legacy backtick `command` substitution
#	disable=SC2006
#	# accept =let EXPR= along with =(( EXPR ))=
#	disable=SC2219
