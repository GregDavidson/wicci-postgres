#!/usr/bin/bash

# Note: =Emacs= =outshine-mode= lets you treat this file as a hierarchical
# document. TAB on comment lines beginning with asterisks will hide/show nodes
# much like with =OrgMode=.

# * Issues

# Prune these issues before this script is released!

# ** Issue: Logging of error messages
# It's not happening!
# How can we streamline this?
# And might as well use something like try

# ** Issue: Build-Depends

# Figuring out build-dependencies, including those needed for the extra features
# we're adding, is a pain. We've always done it by hand before. We're probably
# still going to have to do it mostly by hand, but let's record all of the
# dependencies on our various platforms and see if we can at least document them
# and hopefully semi or fully automate their installation!
# Notes on Proposed Solution with Debian-based Linux:
# Basics:
# $ apt install -y build-essential
# Maybe:
# $ apt install -y autotools-dev dpkg-dev devscripts
# Get the postgresql source package
# $ apt-get build-dep postgresql
# or follow the advise at
# See https://www.guyrutenberg.com/2017/09/23/use-mk-build-deps-instead-of-apt-get-build-dep/
# $ mk-build-deps PKGNAME --install --root-cmd sudo --remove
# and install that
# Install all the other things:
# apt install xsltproc libxslt1.1 libxslt1-dev # check version
# apt install tcl tcl8.6-dev tcllib tclxml # check version
# any libxml2 packages needed??
# apt install tcl8.6-tdbc tcl8.6-tdbc-postgres
# Proposed Solution with Mac: ???
# Solutions for other platforms: ???

# ** Issue: Ensure Accounts Exist

# - bin
# - postgres

# ** Issue: Postgres Account uncomfortable from command shell
# Proposed solution:
# Make sure the account exists with a nice shell.
# - Maybe take the shell from the real-user-id?
# - And/or make it yet another option
# Copy over a nice =skel=
# - start with =/etc/skel=
# Create a =pg_skel= (where?) with
#   - .profile .sh.d/* .guix-profile .config/guix
#   - what goes in .sh.d and what else do we want?

# Issue: Automate connections to Wicci resources
# Proposed solution:
# Automatically add XFiles link to ~postgres/data directory
# Automatically add Wicci/Make/wicci1 to dynamic_librqary_path
# in ~postgres/data/postgresql.conf
# Do other easy changes to ~postgres/data/postgresql.conf
# Provide options for these things!
# - Source Wicci paths script!
# - Make sure it defines these things!

# * Install PostgreSQL for the Wicci

# run with no arguments for help!

# ** Name, Paths, Logs, Error Management

# stop on variable or pipe errors
set -u
set -o pipefail

set -xv                         #get rid of this soon!!

declare -r Pgm_Name="${0##*/}"
declare -r Pgm_Dir="$(realpath $(dirname $0))"

# Mutable Globals
Phase=SETUP                     # Will change! Logs are LOG-$Phase 
Build_Shell='/bin/dash'         # May change!
Build_User='bin'                # May change!
Build_Dir="/tmp/$Pgm_Name-$$"   # Will change!
su -s "$Build_Shell" "$Build_User" -c "mkdir -p $Build_Dir" &&

report_from() {
    local from="$1" shift
    printf -- '%s\n' "$from: $*" |
        su -s $Build_Shell "$Build_User" -c "tee -a $Build_Dir/LOG-$Phase" >&2
}
2>/dev/null report_from '- OK :' "mkdir -p $Build_Dir"

level_report() {
    local from="$Pgm_Name $1"; shift
    report_from "$from" "$@"
}
fn_level_report() {
    local from="$Pgm_Name.$1 $2" ; shift 2
    report_from "$from" "$@"
}
code_error() {
    local code="$1"; shift
    level_report "error $code" "$@"
    exit "$code"
}
code_fn_error() {
    local code="$1" fn="$2"; shift 2
    fn_level_report "$fn" "error $code" "$@"
    exit "$code"
}

# how can we do this just using bash features?
empty_dir() { [ -d "$1" ] && ! ls -qAH -- "$1" | grep -q .; }

# ** Usage Patterns

declare -r options=('--help' '--dryrun' '--verbose')

declare -rA Patterns=( [help]=0 [tarball]=1 [git-dir]=2 [src-dir]=3 )
# In array Arg_Patterns, note Posix documentation convention
# of optional arguments in [square brackets]
declare -ra Arg_Patterns=(
    ''
    'PATH-TO-TARBALL [PARENT-INSTALL-DIR]'
    'VERSION POSTGRESQL-GIT-REPOSITORY [PARENT-INSTALL-DIR]'
    'VERSION [PARENT-INSTALL-DIR]'
)
declare -ra Arg_Pattern_Explanations=(
    'give help'
    'install from tar archive'
    'install specified version from git repository'
    'install specified version from existing source'
)
[ "${#Patterns[@]}" =  "${#Arg_Patterns[@]}" ] ||
    code_error 1 "#Patterns != #Arg_Patterns"
[ "${#Patterns[@]}" =  "${#Arg_Pattern_Explanations[@]}" ] ||
    code_error 2 "#Patterns != #Arg_Pattern_Explanations"

give_full_help() {
    local i
    for i in ${!Arg_Patterns[@]}; do
        printf '%s %s %s\n\t%s\n' \
               "$Pgm_Name" "${Options[*]}" "${Arg_Patterns[$i]}" \
               "${Arg_Pattern_Explanations[$i]}"
    done
}

# ** Who Does What?

su_code_user_cmd exit-code user cmd...
# Every side-effecting command comes through this function!
# Error exit code also indexes command in the script
# Syntax of logfiles is compatible with OrgMode documents
# Commands run and logs live under Build_Dir
su_code_user_cmd() {
    local code="$1" user="$2"; shift 2
    local dir="$Build_Dir"
    local log="$Build_Dir/LOG-$Phase"
    printf '** %d: %s\n- Directory :: %s\n' "$code" "$* $PWD" >> "$log"
    $Dry_Run && return 0
    echo '#+begin_example' >> "$log"
    if su -s "$Build_Shell" "$Build_User" -c "cd ${dir} ; $*" >> $log
    then
        printf -- '- %s!\n#+end_example' OK >> "$log"
        echo "OK: $@"
    else
        printf -- '- %s!\n#+end_example' FAILED >> "$log"
        code_error "$code" "$@ failed!"
    fi
}

su_code_cmd() {
    code="$1" ; shift
    su_code_user_cmd "$code" "$Build_User" "$@"
}

su_pg() {
    code="$1" cmd="$2" ; shift 2
    su_code_user_cmd "$code" postgres "$@"
}

# ** Handle Other Options

Dry_Run='false'
Give_Help='false'
Verbose='false'
Pattern='unknown'

option_arg() {
    case "$1" in
        --dryrun) Dry_Run='true' ;;
        --help) Give_Help='true' ;;
        --verbose) Verbose='true' ;;
        *) return 1 ;;
    esac
    return 0
}

# record and discard option args

# record options and save non-option arguments
Args=( )                        # Non-Option Args
for Arg; do
    option_arg "$Arg" || Args+="$Arg"
done

# Reset command line arguments
set -- "${Args[@]}"             # check this works!
[ "X${Args[*]}" = "X$*" ] || code_error 3 "Args - foiled again!"

# if no non-option arguments, give full help
[ ${#Args[@]} -eq 0 ] && { give_full_help; exit 0; }
# put in the code for targeted help!!

# ** Global Variables

report_initial_globals() {
    echo "Program Name = $Pgm_Name"
    echo "Program Dir = $Pgm_Dir"
    echo "Give Help = $Give_Help"
    echo "Dry Run = $Dry_Run"
    echo "Arguments = ${Args[*]}"
}

$Verbose && report_initial_globals

# we will need values for these global variables
# call this once we've sussed things out from the arguments
suss_globals() {
    local fn='suss_globals'
    Project="${Project:-postgresql-$Version}" ||
        code_fn_error 4 "$fn" "No pg_version!"
    Project_Parent="${Project_Parent:-/usr/local/src}"
    return 0
}

# can't call this yet!
report_sussed_globals() {
    echo "Desired PostgreSQL Version = $Version"
    echo "Project = $Project"
    echo "Project Parent Directory = $Project_Parent"
    echo "Build Directory = $Build_Dir"
}

# ** Determine Argument Patterns and Finalize Globals

# *** tarball pattern

try_tarball() {
#    set -xv
    local fn='try_tarball'
    [ $# -gt 0 -a $# -le 2 ] || return 1
    [ -f "$1" ] || return 1
    if [ $# -gt 1 ]; then
        [ -d "$2" ] || return 1
    fi
    local f1=${1##*/} # without the path
    local f2=${f1%.*} # without last extension
    local f           # trial project name
    case "$f1" in
        (*.tar) f=$f2 ;;
        (*.tar.*) f=${f2%.*} ;;
        (*) return 1;;
    esac
    Pattern='tarball'
    # we're committed, further deviations will be errors
    local v=${f##*-}            # trial version string
    local regexp_pattern='[1-9][0-9]?.[0-9][0-9]?(rc)?'
    [[ "$v" =~ $regexp_pattern ]] ||
        code_fn_error 5 "$fn" "unknown version pattern in $f"
    # We're satisfied, so
    Archive=$(realpath "$1")
    Version="$v"
    Project="$f"
    if [ $# = 2 ]; then
        Project_Parent="$2"
    fi
    return 0
}

# *** version git pattern

try_version_git() {
    local fn='try_version_git'
    pattern='tarball'
    fn_level_report "$fn" apology "$Pattern pattern not yet implemented"
    return 1
}

try_bare_version() {
    local fn='try_bare_version'
    pattern='version'
    fn_level_report "$fn" apology "$Pattern pattern not yet implemented"
    return 1
}

# *** determine install pattern

try_tarball "$@" || try_version_git "$@" || try_bare_version "$@" ||
    code_error 6 'unrecognized install pattern'

suss_globals || code_error 7 "can't suss globals"

# *** Set Install Paths

pgsql_dir="pgsql-$Version"
for dd in /usr/local/SW.d /usr/local/SW /usr/local; do
    [ -d "$dd" ] && pgsql_path="$dd/$pgsql_dir" && break
done
pgsql_bin="$pgsql_path/bin"
pgsql_data="$pgsql_path/data"
pgsql_log="$pgsql_data/logfile"
pgsql_conf="$pgsql_data/postgresql.conf"
pgsql_conf_orig="$pgsql_conf-$Version"

# *** Try to find tcl library

for tcl in /usr/{lib,lib64}{,/tcl*}/tclConfig.sh; do
    [ -f "$tcl" ] && break
done
if [ -f "${tcl:-}" ]; then
    with_tcl="--with-tcl with_tclconfig=--with-tclconfig=${tcl%/*}"
else
    with_tcl=''
    level_report warning "Can't find tcl, will proceed without it!!"
fi

# ** Prepare, Configure, Build, Install

# *** Prepare Build Directory

cd "$Project_Parent" || code_error 8 "Can't cd to project parent directory $Project_parent"
su_code_cmd 9 mkdir -p "$Project_Parent/$Project"
cd "$Project" || code_error 10 "Can't cd to project directory $Project_Parent/$Project"

# get_empty_code_user_path EXIT-CODE USER DIR_PATH
# Create or find empty directory DIR_PATH
get_empty_code_user_path() {
    local code="$1" user="$2" path="$3" fn='get_empty_code_user_path'
    su_code_user_cmd "$code" "$user" mkdir -p "$path"
    empty_dir "$path" || code_fn_error "$code" "$fn" "Expected empty_dir $path"
}

# extract_archive TARBALL PROJECT [DEST-DIR=.] [TEMP-DIR=Temp]
# safely extract the given archive to an empty TEMP-DIR
# move the TEMP-DIR/PROJECT result to DEST-DIR
# remove the now-empty TEMP-DIR
untar_archive() {
    local a="$1" p="$2" d="${3:-.}" t="${4:-Temp}" fn='untar_archive'
    ( Dry_Run=false; get_empty_code_user_path 11 "$Build_User" "$t" ) # debug!!!
    su_code_cmd 12 tar -C "$t" -xf "$a" ||
        code_fn_error 13 "$fn" "Can't extract $a in $(real_dir $t)"
    su_code_cmd 14 mv "$t/$p" "$d" ||
        code_fn_error 15 "$fn" "Can't mv $t/$p $d"
    su_code_cmd 16 rmdir "$t" ||
        code_fn_error 17 "$fn" "Can't remove temporary directory $(real_dir $t)"
}

# Skip any build directories from prior attempts
get_build_dir() {
    local n=1 parent="$Project_Parent/$Project" fn='get_build_dir'
    cd "$parent" || code_fn_error 18 "$fn" "Can't cd to $parent"
    while [ -d "Attempt-$n" ] && ! empty_dir "Attempt-$n" ; do
        let ++n
    done
    local old="$Build_Dir" new="$parent/Attempt-$n"
    su_code_user_cmd 18 root "chown -R $Build_User $old"
    get_empty_code_user_path 19 "$Build_User" "$new"
    su_code_cmd 20 mv "$old"/* "$new"
    declare -r Build_Dir="$new" # should not change again
    cd "$Build_Dir" ||
        code_fn_error 21 "$fn" "Can't cd to build directory $Build_Dir"
}

get_build_dir

$Verbose && report_sussed_globals

case "$Pattern" in
    (tarball)
        untar_archive "$Archive" "$Project"
        su_code_cmd 22 chmod -R a-w "$Project"
        untar_archive "$Archive" "$Project" "$Build_Dir"
        ;;
    (*) fn_level_report "$fn" apology "$Pattern pattern not yet implemented"
        exit 23 ;;
esac

# *** Try to configure, build and install PostgreSQL
echo We will now try to configure, make and install a new PostgreSQL

Phase=CONFIG

Config_Options=(
    --with-libxml
    --with-libxslt
    --enable-debug
    --enable-cassert
    $with_tcl
    --prefix="$pgsql_path"
)

su_code_cmd 24 ./configure ${Config_Options[*]}

Phase=BUILD

su_code_cmd 25 make

Phase=INSTALL

get_empty_code_user_path 26 postgres "$pgsql_path"
su_code_cmd 27 make install

# *** Try to configure, build and install some contributed modules

# add some contributed modules
cd "$Build_Dir/contrib" || code_error 28 "Can't cd to $Build_Dir/contrib"

for d in xml2 intarray citext hstore; do
	(
      Phase=$d-BUILD
      su_code_user_cmd 29 "$Build_User" make
      Phase=$d-INSTALL
      su_code_user_cmd  30 "$Build_User" make install
  )
done

# *** Procedures to run as Postgres

su_pg_data() {
    local code="$1" cmd="$2" ; shift 2
    su_pg "$code" "$cmd" -D "$pgsql_data" "$@"
}

Phase=POSTGRES

su_pg 31 "mkdir $pgsql_data"

# initialize the PostgreSQL system
su_pg_data 32 initdb

# start the PostgreSQL server
su_pg_data 33 pg_ctl -l $pgsql_log start
sleep 5	# seems to need a moment to get ready

# add needed languages to database template1
Langs="pltcl"
# case "$Version" in
#     8*) Langs="plpgsql $Langs" ;;
# esac
for lang in "$Langs"; do
	# try $pgsql_bin/createlang "$lang" template1
	echo "create trusted procedural language '$lang';" | su_pg 34 psql template1
done

# create some databases
su_pg 35 createdb wicci1
echo "PostgreSQL installed into $pgsql_path"
echo "$pgsql_path linked to $pgsql_link"
su_pg 36 mv $pgsql_conf $pgsql_conf_orig
su_pg 37 cp $pgsql_conf_orig $pgsql_conf

# create some PostgreSQL superusers
# these should really come from the command line
# perhaps defaulting to the real-user-id

echo -n 'Who should we make be PostgreSQL superuser(s)? '
read users
for user in $users; do
	if awk -F: -v "u=$user" '$1==u{x=1}END{exit x}' /etc/passwd
	then echo "No user $user"
	else su_pg 38 createuser --superuser $user
	fi
done
echo "Configure $pgsql_conf, etc.  For the Wicci:
(1) add the Make/wicci1 directory to dynamic_library_path
(2) symlink the XFiles directory to the PostgreSQL data directory
Restart the server and Have Fun!"
