#!/usr/bin/bash

# * Install PostgreSQL for the Wicci

# ** Some Initial Words

# Run this script with no arguments for help!

# All action is orchestrated at the end of the script
# by calling the functions whose names begin with do_

# Note: =Emacs= =outshine-mode= lets you treat this file as a hierarchical
# document. TAB on comment lines beginning with asterisks will hide/show nodes
# much like with =OrgMode=.

# Turn on tracing before troublesome code
# set -vx                         # DEBUG !!
# Turn off tracing following troublesome code
# set +vx                         # DEBUG !!

# ** A Few Initial Settings

# exit on command failures
# set -e
# is currently commented out as some of our functions "fail"!
# Research this as it would be nice to reinstate this protection!
# Possibly we're lacking a few strategic
#   return 0 # as last statement in a function
#   || true  # at end of an expression
# - but don't add these gratuitously or you'll conceal errors!
# Note that vaiable settings don't change exit status, so
#   COMMAND || VARIABLE-SETTING
# Should be rewritten as
#   COMMAND || VARIABLE-SETTING || true

set -u                          # exit when referencing undefined variables
set -o pipefail                 # capture last non-zero status in pipeline

readonly Pgm_Name="${0##*/}"    # Name of this script
readonly Pgm_Dir="$(realpath "$(dirname "$0")")"

# Early_Globals will be logged once logging is available
declare -a Early_Globals=(Pgm_Name Pgm_Dir)

# ** Usage Help

# How this script can be used

declare -r Options=('--help' '--dryrun' '--verbose')

declare -rA Patterns=( [help]=0 [tarball]=1 [git-dir]=2 [src-dir]=3 )

# In array Arg_Patterns, note Posix documentation convention
# of optional arguments in [square brackets]
declare -ra Arg_Patterns=(
''
'PATH-TO-TARBALL [PARENT-INSTALL-DIR]'
'VERSION POSTGRESQL-GIT-REPOSITORY [PARENT-INSTALL-DIR]'
'VERSION [PARENT-INSTALL-DIR]'
)
declare -ra Arg_Pattern_Explanations=(
'give help'
'install from tar archive'
'install specified version from git repository'
'install specified version from existing source'
)

# These three arrays should have the same number of elements
[ "${#Patterns[@]}" =  "${#Arg_Patterns[@]}" ] ||
    error "`cr 10 70 "$Pgm_Name"`" "#Patterns != #Arg_Patterns"
[ "${#Patterns[@]}" =  "${#Arg_Pattern_Explanations[@]}" ] ||
    error "`cr 11 72 "$Pgm_Name"`" "#Patterns != #Arg_Pattern_Explanations"

give_full_help() {
    local i
    for i in ${!Arg_Patterns[@]}; do
        printf -- '%s %s %s\n\t%s\n' \
               "$Pgm_Name" "${Options[*]}" "${Arg_Patterns[$i]}" \
               "${Arg_Pattern_Explanations[$i]}"
    done
    printf -- 'Caveats:\n'
    printf -- '\t%s\n' 'Currently needs to run as root.'
    printf -- '\t%s\n' 'Unmet dependencies should cause it to abort.'
    printf -- '\t%s\n' 'Logs and work done so far left for you to examine.'
    printf -- '\t%s\n' 'Too many assumptions for any hard guarantees!'
    printf -- '\t%s\n' 'May behave arbitrarily badly in unfamiliar environment.'
}

# ** Reporting, Context, Logging, Setting Parameters

# Reports will go to $Log_File once it has a value
declare -g Log_File             # no value yet!

# And Reports will go to stderr or stdout
# - when Log_File is NOT set
# - when Verbose = true

# *** Context for Reports

# Context is everything! Reports, including Warnings and Error Messages need to
# report context. A ContextSequence is a space-separated string consisting of a
# ContextRecords. A ContextRecord is a colon (:) separated record of an
# ExitCode, LineNumber and optional entities such as FunctionNames and
# ParameterSettings - which must not contain either spaces or colons. These
# ContextSequences generally grow as they're passed as FunctionArguments.
# ExitCodes and LineNumbers are generally computed by a tool.

# cs makes context sequences
# cs existing-context-sequence context-record-arguments
cs() {
    cs0="$1"; shift
    printf -- '%s%s%s' "$(cr "$@")" "${cs0:+ }" "$cs0"
}

# cr makes ContextRecords which are also ContextSequence singletons
# cr exit_code line_number [entity...]
cr() {
    local IFS=':'
    printf -- '%s' "$*"
}

# burst a ContextRecord into space-separated fields
cr_burst() {
    local IFS=':'
    local fields
    read -ra fields <<< "$1"
    IFS=' '
    printf -- '%s' "${fields[*]}"
}

# test whether the argument appears to be a ContextSequence
is_cs() {
    [ -z "$1" ] || [[ "X$1" =~ ^X[0-9]+: ]]
}

# cs_code [CONTEXT]
# returns the first ExitCode in the ContextSequence
# - default to 9 if none is specified by the context
# - ( generated ExitCodes begin with 10 )
cs_code() {
    local context="${1:-}"                  # default to empty context
    local code="${context%%[!0-9]*}"         # strip starting with 1st non-digit
    printf -- "%d" "${code:-9}"             # return the code to use
    [ -n "$code" ]                          # return whether it was specified
}

# *** Reporting

# report_out [-LEVEL] [CONTEXT] [FORMAT] REPORT...
# All report messages go through here.
# Formats should work well with OrgMode.
# Currently any supplied FORMAT option is ignored.
report_out() {
    local level='' context='' format='' cr
    # get the "level", if any
    [[ "X$1" =~ ^X- ]] && {
        level="${1#-}"          # strip initial -
        shift                   # drop argument
    }
    # get the context, if any
    is_cs "$1" && { context="$1"; shift; }
    # get the "format", if any
    case "$1" in
        (:*|-:*) format="$1" ; shift ;;
    esac
    # make the main report
    case "$level" in
        ?*) # OrgMode definition-list format when level non-empty
            printf -- '- %s :: %s\n' "$level" "$*" ;;
        *)  # no format applied when level is empty
            printf -- '%s\n' "$*" ;;
    esac
    # follow with all supporting context
    for cr in $context; do
        printf -- '- context: %s\n' "$(cr_burst "$cr")"
    done
}

# same interface as report_out
# report to stdout if Verbose or no Log_File
# report to Log_File if it exists
report() {
    { "${Verbose:-false}" || [ -z "${Log_File:-}" ]; } && report_out "$@"
    [ -n "${Log_File:-}" ] && report_out "$@" >> "$Log_File"
}

# error [CONTEXT] REPORT...
error() {
    local code=$(cs_code "$1")
    >&2 report -error "$@"
    exit "$code"
}

# *** Setting and Reporting Global Parameters

# Use these functions to set global parameters
# so that the settings get reported!

# report_param global_parameter
report_param() {
    local -n p="$1"     # alias p to the parameter
    report -"\$$1" '' "$p"
}

# report_param global_array_parameter
report_param_array() {
    local -n a="$1"     # alias a to the array
    local i
    report -"$1[]" '' Elements
    for i in ${!a[@]}; do
        report -"[$i]" '' "${a[$i]}"
    done
}

# report_params PARAMETER...
report_params() {
    local p; for p; do report_param "$p"; done
}

# logging issue!!!
# set_param global_parameter [value]
set_param() {
    { [ $# -ge 1 ] && [ $# -le 2 ]; } ||
        error "set_param given $# arguments"
    declare -g "$1"             # declare as global parameter
    [ $# -eq 1 ] && return 0
    local -n param="$1"         # alias as param
    param="$2"                  # set its value
    report_param "$1" # report it
    # if report couldn't log it, record it for later
    [ -n "${Log_File:-}" ] || Early_Globals+=("$1")
}

# set_final global_parameter [value]
set_final() {
    set_param "$@"
    declare -gr "$1"            # declare as global readonly
}

# ** Set Accounts and Locations

# Using grep
# Assumes FILE is Posix /etc/passwd or /etc/group
# user_group_exists NAME 'user|group' FILE [CONTEXT]
user_group_exists() {
    local context="${4:-}"
    grep -qs "^$1:" "$3" || error "$context" "No $2 $1 in $3"
    printf -- '%s' "$1"            # return value
}
# user_exists USER-NAME [CONTEXT]
user_exists() { user_group_exists "$1" 'user' '/etc/passwd' "${2:-}"; }
# group_exists GROUP-NAME [CONTEXT]
group_exists() { user_group_exists "$1" 'group' '/etc/group' "${2:-}"; }

do_set_accounts() {
    local this=do_suss_accounts

    # The Account and Group which we use to configure and build PostgreSQL
    set_final Build_Acct "$(user_exists bin "`cr 12 259 $this`")"
    set_final Build_Group "$(group_exists bin "`cr 13 260 $this`")"
    # The Account and Group which owns the installed PostgreSQL
    set_final PG_Acct "$(user_exists postgres "`cr 14 262 $this`")"
    set_final PG_Group "$(group_exists postgres "`cr 15 263 $this`")"
}

do_set_locations() {
    local this=do_suss_locations

    set_final Build_Grandparent_Dir /usr/local/src
    [ -d "$Build_Grandparent_Dir" ] ||
        error "`cr 16 271 $this`" expected directory "$Build_Grandparent_Dir"

    for d in /usr/local/SW.d /usr/local/SW /usr/local; do
        [ -d "$d" ] && break
    done
    [ -d "$d" ] || error "`cr 17 276 $this`" "expected PG_Parent_Dir $d"
    set_final PG_Parent_Dir "$d"
}

# ** Process Command Line Options

# Find the path to a program with fallbacks, or fail
# try_find_prog_path PROGRAM_NAME...
try_find_prog_path() {
    # set -vx                         # DEBUG !!
    local prog path=''
    for prog; do
        path="$(type -P "$prog" 2>/dev/null)" && break
    done
    [ $? -eq 0 ] && printf -- '%s' "$path"
}

option_arg() {
    case "$1" in
        --dryrun) set_param Dry_Run 'true' ;;
        --help) set_param Give_Help 'true' ;;
        --verbose)
            # Verbose is temporarily set to off while reporting Early_Globals
            # so it's incorrectly reported as being false :-(
            # Not using set_param is an evil patch :-( !!
            declare -g Verbose='true' ;;
        *) return 1 ;;
    esac
    return 0
}

do_suss_options() {
    local this=do_suss_options
    local arg
    # These are just defaults so we're not going to report them!
    declare -g Dry_Run='false'
    declare -g Give_Help='false'
    declare -g Verbose='false'
    declare -g Pattern='unknown'
    # Consider making this a command-line option instead!!
    set_param Build_Shell "$(try_find_prog_path dash sh)" ||
        error "`cr 18 317 $this`" "can't suss Build_Shell"
    set_final Build_Shell;

    # record options and save non-option arguments
    declare -g Pgm_Args=( )                        # Non-Option args
    for arg; do
        option_arg "$arg" || Pgm_Args+=("$arg")
    done

    # if asked or if no non-option arguments, give full help
    { "$Give_Help" || [ ${#Pgm_Args[@]} -eq 0 ]; } && { give_full_help; exit 0; }
    return 0
}

# ** Suss Argument Pattern to Finalize Globals

# Roadmap item for targeted --help !!
# Once a pattern is sussed or while it's being sussed
# When the --help option was given
# Explain the pattern and exit 0

# *** Tarball Pattern

try_tarball() {
    local this='try_tarball'
    [ $# -gt 0 ] && [ $# -le 2 ] || return 1
    [ -f "$1" ] || return 1
    [ $# -eq 1 ] || expect_dir "$2" "`cr 19 344 $this`"
    local f1=${1##*/} # without the path
    local f2=${f1%.*} # without last extension
    local f           # trial project name
    case "$f1" in
        (*.tar) f=$f2 ;;
        (*.tar.*) f=${f2%.*} ;;
        (*) return 1;;
    esac
    set_final Pattern 'tarball' # commit to pattern
    # further deviations will be errors
    local v=${f##*-}            # trial version string
    local regexp_pattern='[1-9][0-9]?.[0-9][0-9]?(rc)?'
    [[ "$v" =~ $regexp_pattern ]] ||
        error "`cr 20 358 $this`" "unknown version pattern in $f"
    # We're satisfied, so
    set_final Archive $(realpath "$1")
    set_final Version "$v"
    [ $# = 2 ] && set_final Build_Grandparent_Dir "$(realpath "$2")"
    expect_dir "$Build_Grandparent_Dir" "`cr 21 363 $this`"
    return 0
}

# *** Other Patterns

try_version_git() {
    local this='try_version_git'
    set_final Pattern 'tarball'
    report -apology "`cr 22 372 $this`" "$Pattern pattern not yet implemented"
    return 1
}

try_bare_version() {
    local this='try_bare_version'
    set_final Pattern 'version'
    context_level_report "`cr 23 379 $this`" apology "$Pattern pattern not yet implemented"
    return 1
}

# *** Determine Install Pattern

do_suss_args() {
    local this=do_suss_args

    try_tarball "$@" || try_version_git "$@" || try_bare_version "$@" ||
        error "`cr 24 389 $this`" 'unrecognized install pattern'

    [ -n "$Version" ] ||
        error "`cr 25 392 $this`" "Failed to suss a version"
}

# *** Try to find tcl library

do_try_find_tcl() {
    local tcl this=do_try_find_tcl
    for tcl in /usr/{lib,lib64}{,/tcl*}/tclConfig.sh
    do
        [ -f "$tcl" ] && break
    done
    if [ -f "${tcl:-}" ]; then
        with_tcl="--with-tclconfig=${tcl%/*}"
    else
        with_tcl=''
        report -warning "`cr 26 407 $this`" "Can't find tcl, will proceed without it!!"
    fi
}

# *** Given Version, Finalize Build and PG Dirs

# Using ls, grep
# empty_dir() { ! [ -e "$1" ] || [ -d "$1"] && ! ls -qAH -- "$1" | grep -q .; }
# just using bash builtin features
empty_dir() {
    ! [ -e "$1" ] || [ -d "$1" ] && ! [[ $(shopt -s nullglob dotglob; echo "$1"/*) ]];
}

# expect_dir PATH [CONTEXT]
expect_dir() {
    [ -d "$1" ] || error "${2:-}" "Expected directory $1"
}

# Using mkdir, chown
# ensure directory exists at PATH or mkdir and chown it
# ensure_dir PATH ACCOUNT GROUP [CONTEXT]
ensure_dir() {
    local dir="$1" acct="$2" group="$3" cxt="${4:-}"
    [ -d "$dir" ] || {
        [ -e "$dir" ] &&          # whoops, something else there!
            error "$cxt" "Expected directory $dir"
        report -command "$cxt" mkdir -p "$dir"
        mkdir "$dir"
        report -command "$cxt" chown "$acct:$group" "$dir"
        chown "$acct:$group" "$dir"
    }
}

# when we know the version, create the build directories
# do_suss_build_dirs VERSION
do_suss_build_dirs() {
    local this=do_suss_build_dirs
    set_final Project_Name "PostgreSQL-$1"
    set_final Source_Name "${Project_Name,,}" # lower case
    set_final Build_Parent_Dir "$Build_Grandparent_Dir/$Project_Name"
    ensure_dir "$Build_Parent_Dir" "$Build_Acct" "$Build_Group" "`cr 27 447 $this`"
    local n=1 d
    while d="$Build_Parent_Dir/Attempt-$n" ; ! empty_dir "$d"; do
        let ++n
    done
    set_final Build_Dir "$d"
    ensure_dir "$Build_Dir" "$Build_Acct" "$Build_Group" "`cr 28 453 suss_build_dirs`"
}

# when we know the version, create the PG Dirs
# Initially they'll be owned by the $Build_Acct
# Later they'll be =chown=ed to the $PG_Acct
# do_suss_pg_dirs VERSION
do_suss_pg_dirs() {
    local this=do_suss_pg_dirs
    set_final PG_Dir "$PG_Parent_Dir/pgsql-$1"
    local n=1 old
    [ -d "$PG_Dir" ] && ! empty_dir "$PG_Dir" && {
            while old="$PG_Dir-$n"; [ -d "$old" ]; do
                let ++n
            done
            report -"install conflict warning" "`cr 29 468 $this`" \
                   mv "$PG_Dir" "$old"
            mv "$PG_Dir" "$old"
        }
    ensure_dir "$PG_Dir" "$Build_Acct" "$Build_Group" "`cr 30 472 $this`"
    set_final PG_Bin "$PG_Dir/bin"
    set_final PG_Data "$PG_Dir/data"
    set_final PG_Log "$PG_Data/logfile"
    set_final PG_Conf "$PG_Data/postgresql.conf"
    set_final PG_Conf_Orig "$PG_Conf-$Version"
}

# ** Prepare, Configure, Build, Install

# *** su commands

# su_acct_dir_cmd [CONTEXT] account directory command...
# use this one when you musn't add anything to stdout
su_acct_dir_cmd() {
    local cxt=''                # will grow
    is_cs "$1" && { cxt="$1"; shift; }
    local acct="$1" dir="$2";  shift 2
    # abuse our knowledge of ContextSeqence representation and watch out:
    # - spaces or colons in the variables will produce a messy report!
    cxt="$(cr 1 acct = "$acct") $(cr 2 dir = "$dir") $(cr 3 shell = "$Build_Shell") $cxt"
    >&2 report -command "$cxt" "$*"
    "$Dry_Run" || su - "$acct" -s "$Build_Shell" -c "cd \"$dir\"; $*"
}

# su_acct_dir_cmd_log [CONTEXT] account directory command...
su_acct_dir_cmd_log() {
    local cxt=''                # will grow
    is_cs "$1" && { cxt="$1"; shift; }
    local acct="$1" dir="$2";  shift 2
    # abuse our knowledge of ContextSeqence representation and watch out:
    # - spaces or colons in the variables will produce a messy report!
    cxt="$(cr 1 acct = "$acct") $(cr 2 dir = "$dir") $(cr 3 shell = "$Build_Shell") $cxt"
    report -command "$cxt" "$*"
    "$Dry_Run" || su - "$acct" -s "$Build_Shell" -c "cd \"$dir\"; $*" | log_example
}

# *** Prepare Build Directory With Fresh Source

do_prepare_build_dir() {
    local this=do_prepare_build_dir

    case "$Pattern" in
        (tarball)
        set_param Source_Dir "$Build_Parent_Dir/$Source_Name"
        ensure_dir "$Source_Dir" "$Build_Acct" "$Build_Group" \
                   "`cr 31 518 $this`"
        report -command "`cr 32 519 $this`" \
               chown -R "$Build_Acct:$Build_Group" "$Build_Dir"
        chown -R "$Build_Acct:$Build_Group" "$Build_Parent_Dir"
        local cxt1="`cr 33 522 $this`"
        su_acct_dir_cmd "$cxt1" "$Build_Acct" "$Build_Parent_Dir" \
                        tar xf "$Archive" ||
            error "$cxt1" "Can't extract $Archive"
        "$Dry_Run" || ! empty_dir "$Source_Dir"  ||
            expect_dir "$Source_Dir" "`cr 34 527 $this`"
        su_acct_dir_cmd "`cr 35 528 $this`" "$Build_Acct" "$Build_Parent_Dir" \
                        tar cf - "$Source_Name" |
            su_acct_dir_cmd "`cr 36 530 $this`" "$Build_Acct" "$Build_Dir" \
                            tar xf - ||
            error "`cr 37 532 $this`" "Can't copy $Source_Dir to $Build_Dir"
        ;;
        (*) error "`cr 38 534 $this`" "unimplemented pattern $Pattern" ;;
    esac
    return 0
}

# *** Logging Functions

set_phase() {
    declare -g Phase="$1"
    declare -g Log_File="$Build_Dir/LOG_$Phase.org"
    touch "$Log_File"
    chown -R "$Build_Acct:$Build_Group" "$Log_File"

    { printf -- '%s -*- mode: %s; -*-\n' '' Org
      printf -- '#+%s: %s\n' TITLE 'PostgreSQL for Wicci Installation Log'
      printf -- '#+%s: %s\n' DATE "$(date)"
      printf -- '\n'
    } >> "$Log_File"

    [ "${#Early_Globals[@]}" -gt 0 ] && {
        declare -g Verbose
        local verbose="$Verbose"
        Verbose='false'
        report '' '* Early Globals:'
        report -'Pgm_Args[]' "${Pgm_Args[*]}"
        report_params "${Early_Globals[@]}"
        Early_Globals=( )
        Verbose="$verbose"
    }

    report '' "* Phase $Phase"
}

# Using awk
# log stdin content, if any, as an OrgMode example block
log_example() {
    awk -v b='#+begin_example' -v e='#+end_example' \
        'NR==1{print b}NR>0{print}END{if (NR>0) print e}' | tee -a "${Log_File:-/dev/null}"
}

# log_error CONTEXT REPORT...
log_error() {
    local code=$(get_exit_code "$1")
    report -error "@"
    exit "$code"
}

# *** Phase CONFIG

do_config() {
    local this=do_config

    set_phase CONFIG

    set_param Source_Root "$Build_Dir/$Source_Name"
    ensure_dir "$Source_Root" "$Build_Acct" "$Build_Group"  "`cr 39 589 $this`" 

    # disable shellcheck wanting quotes around $with_tcl
    # shellcheck disable=SC2206
    declare -g Config_Options=(
        --with-libxml
        --with-libxslt
        --enable-debug
        --enable-cassert
        $with_tcl                   # don't quote!
        "--prefix=$PG_Dir"
    )

    $Verbose && report_param_array Config_Options

    local cxt="`cr 40 604 $this`"
    su_acct_dir_cmd_log "$cxt" "$Build_Acct" "$Source_Root" ./configure "${Config_Options[*]}" ||
        log_error "$cxt" "./configure -> $?"
}

# *** Phases BUILD and INSTALL

do_build() {
    local this=do_build

    set_phase BUILD

    local cxt="`cr 41 616 $this`"
    su_acct_dir_cmd_log "$cxt" "$Build_Acct" "$Source_Root" make ||
        log_error "$cxt" "make -> $?"
}

do_install() {
    local this=do_install

    set_phase INSTALL

    local cxt="`cr 42 626 $this`"
    su_acct_dir_cmd_log "$cxt" "$Build_Acct" "$Source_Root" make install ||
        log_error "$cxt" "make install -> $?"
}

# *** BUILD and INSTALL Some Contributed Modules

do_build_install_contribs() {
    local d this=do_build_install_contribs

    set_final Contrib_Dir "$Source_Root/contrib"
    expect_dir "$Contrib_Dir" "`cr 43 637 $this`"

    for d in xml2 intarray citext hstore
    do
        set_phase $d-BUILD
        local cxt1="`cr 44 642 $this`"
        su_acct_dir_cmd_log "$cxt1" "$Build_Acct" "$Contrib_Dir" make ||
            error "$cxt1" "make -> $?"

        set_phase $d-INSTALL
        local cxt2="`cr 45 647 $this`"
        su_acct_dir_cmd_log "$cxt2" "$Build_Acct" "$Contrib_Dir" make install ||
            error "$cxt2" "make install -> $?"
    done
}

# ** Setting Up Postgres
# *** Procedures to run as Postgres

# pg_cmd [CONTEXT] command...
pg_cmd() {
    local cxt=''
    is_cs "$1" && { cxt="$1"; shift; }
    su_acct_dir_cmd_log "$cxt" "$PG_Acct" "$PG_Dir" "bin/$*"
}

# pg_data_cmd [CONTEXT] command...
pg_data_cmd() {
    local cxt=''
    is_cs "$1" && { cxt="$1"; shift; }
    local cmd="$1"; shift
    pg_cmd "$cxt" "$cmd" -D "$PG_Data" "$@"
}

# try [CONTEXT] COMMAND...
try() {
    local cxt=''
    is_cs "$1" && { cxt="$1"; shift; }
    report -command "$cxt" "$@"
    "$@" || error "$cxt" "$Phase $1 -> $?"
}

# *** Initializing Postgres

do_init_pg() {
    local this=do_init_pg
    ensure_dir "$PG_Data" "$PG_Acct" "$PG_Group" "`cr 46 683 $this`"
    try "`cr 47 684 $this`" empty_dir "$PG_Data"
    try "`cr 48 685 $this`" chmod 700 "$PG_Data"
    # Change whole install area ownership from Build_Acct to PG_Acct
    try "`cr 49 687 $this`" chown -R "$PG_Acct:$PG_Group" "$PG_Dir"
    pg_data_cmd "`cr 50 688 $this`" initdb ||
        error "`cr 51 689 $this`" "initdb -> $?"
    # we should take care of this: !!
    report "`cr 52 691 $this`" "-remember to" \
           "ln -s XFiles directory to $PG_Data"
}

# *** Starting the Server

do_start_pg() {
    local this=do_start_pg
    # Check if there's an existing PostgreSQL running
    # and do something appropriate if there is!!

    # start the PostgreSQL server
    pg_data_cmd "`cr 53 703 $this`" "pg_ctl -l $PG_Log" start ||
        error "`cr 54 704 $this`" "starting server -> $?"
    sleep 5	# seems to need a moment to get ready
}

# *** Configuring PostgreSQL

# add additional languages to database template1
do_add_langs() {
    local this=do_add_langs
    local lang langs='pltcl'
    set_param PG_Problem_Count  # might already exist, otherwise now 0
    for lang in $langs; do
        # try $PG_Bin/createlang "$lang" template1
        printf -- "create trusted procedural language '%s';\n" "$lang" |
            pg_cmd "`cr 55 718 $this`" psql -a template1 || {
            report "`cr 56 719 $this`" "createlang $lang -> $?"
            let ++PG_Problem_Count
        }
    done
}

# try to create some databases
do_create_databases() {
    local db this=do_create_databases
    for db in wicci1
    do
        pg_cmd "`cr 57 730 $this`" createdb "$db" || {
            report "`cr 58 731 $this`" "createdb $db -> $?"
            let ++PG_Problem_Count
        }
    done
}

do_manage_pg_config_file() {
    local this=do_manage_pg_config_file
    pg_cmd "`cr 59 739 $this`" mv "$PG_Conf" "$PG_Conf_Orig" ||
        report "`cr 60 740 $this`" "mv ${PG_Conf##*/} -> $?"
    pg_cmd "`cr 61 741 $this`" cp "$PG_Conf_Orig" "$PG_Conf" ||
        report "`cr 62 742 $this`" "cp ${PG_Conf##*/} -> $?"
    # we should take care of this: !!
    report "`cr 63 744 $this`" '-remember to' \
           'add Make/wicci1 to dynamic_library_path'
    # and any other typical changes
}

# create some PostgreSQL superusers
# these should really come from the command line or a config file!!
# and/or default to the real-user-id
do_create_superusers() {
    local users this=do_create_superusers

    echo -n 'Who should we make be PostgreSQL superuser(s)? '
    read -r users
    for user in $users; do
        { user_exists "$user" && pg_cmd "`cr 64 758 $this`" createuser --superuser "$user"; } ||
                report "`cr 65 759 $this`" "createuser $user -> $?"
    done
}

# ** Putting it all together

# We need a mechanism for skipping doing a reasonable subset of the steps

do_set_accounts
do_set_locations
# Store script OPTIONS as parameter values
# put regular options into global array Pgm_Args
do_suss_options "$@"
set -- "${Pgm_Args[@]}"      # options now gone from "$@"

test root = "`whoami`" || error "`cr 66 774 "$Pgm_Name"`" "Must run as root!"
do_suss_args "$@"
# Find location of special libraries
do_try_find_tcl
do_suss_build_dirs "$Version"
do_suss_pg_dirs "$Version"

do_prepare_build_dir
do_config
do_build
do_install

do_build_install_contribs

set_phase POSTGRES

declare -g PG_Problem_Count=0

do_init_pg
do_start_pg
do_add_langs
[ "$PG_Problem_Count" -eq 0 ] && do_create_databases
do_manage_pg_config_file
do_create_superusers

echo 'Configure $PG_Conf, etc.  For the Wicci:
(1) add the Make/wicci1 directory to dynamic_library_path
(2) symlink the XFiles directory to the PostgreSQL data directory
Restart the server and Have Fun!'


# ** Some Final Words

# This script is limited and fragile. There should be another file, possibly
# named pg-install.org which describes this script's infelicities and
# development roadmap in more detail.

# I've used the shellcheck program to help catch mistakes
# with these .shellcheckrc settings:
#	# accept legacy backtick `command` substitution
#	disable=SC2006
#	# accept =let EXPR= along with =(( EXPR ))=
#	disable=SC2219
